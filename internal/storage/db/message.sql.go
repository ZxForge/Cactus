// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: message.sql

package db

import (
	"context"
	"database/sql"
	"encoding/json"

	"github.com/google/uuid"
)

const createMessage = `-- name: CreateMessage :one
INSERT INTO message (
    id_worker,
    id_type_worker,
    id_system,
    "uuid",
    value,
    id_priority,
    send_later
) 
VALUES ($1, $2, $3, $4, $5, $6, $7)
RETURNING id, id_worker, id_type_worker, id_system, id_priority, uuid, value, send_later, create_at
`

type CreateMessageParams struct {
	IDWorker     sql.NullInt32   `json:"id_worker"`
	IDTypeWorker int32           `json:"id_type_worker"`
	IDSystem     int32           `json:"id_system"`
	Uuid         uuid.UUID       `json:"uuid"`
	Value        json.RawMessage `json:"value"`
	IDPriority   int32           `json:"id_priority"`
	SendLater    sql.NullTime    `json:"send_later"`
}

func (q *Queries) CreateMessage(ctx context.Context, arg CreateMessageParams) (Message, error) {
	row := q.db.QueryRowContext(ctx, createMessage,
		arg.IDWorker,
		arg.IDTypeWorker,
		arg.IDSystem,
		arg.Uuid,
		arg.Value,
		arg.IDPriority,
		arg.SendLater,
	)
	var i Message
	err := row.Scan(
		&i.ID,
		&i.IDWorker,
		&i.IDTypeWorker,
		&i.IDSystem,
		&i.IDPriority,
		&i.Uuid,
		&i.Value,
		&i.SendLater,
		&i.CreateAt,
	)
	return i, err
}

const getMessagesBy = `-- name: GetMessagesBy :many
SELECT id, id_worker, id_type_worker, id_system, id_priority, uuid, value, send_later, create_at FROM message m 
WHERE m.id_type_worker = $1 AND m.id_system = $2
`

type GetMessagesByParams struct {
	IDTypeWorker int32 `json:"id_type_worker"`
	IDSystem     int32 `json:"id_system"`
}

func (q *Queries) GetMessagesBy(ctx context.Context, arg GetMessagesByParams) ([]Message, error) {
	rows, err := q.db.QueryContext(ctx, getMessagesBy, arg.IDTypeWorker, arg.IDSystem)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Message
	for rows.Next() {
		var i Message
		if err := rows.Scan(
			&i.ID,
			&i.IDWorker,
			&i.IDTypeWorker,
			&i.IDSystem,
			&i.IDPriority,
			&i.Uuid,
			&i.Value,
			&i.SendLater,
			&i.CreateAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStatusMessageByUUID = `-- name: GetStatusMessageByUUID :one
WITH min_step AS (
    SELECT MIN(step) AS min_step
    FROM pipline
    WHERE time_end IS NULL
)
SELECT ps."name" as status FROM pipline_status ps 
JOIN pipline p ON p.id_pipline_status = ps.id
JOIN message m on m.id = p.id_message
JOIN min_step ms ON p.step = ms.min_step
WHERE m."uuid" = $1
`

func (q *Queries) GetStatusMessageByUUID(ctx context.Context, argUuid uuid.UUID) (string, error) {
	row := q.db.QueryRowContext(ctx, getStatusMessageByUUID, argUuid)
	var status string
	err := row.Scan(&status)
	return status, err
}
